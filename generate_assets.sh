#!/bin/bash

# Purpose: Generate a Dart class for assets to provide type-safe access.
# This script scans the ASSETS_DIR and creates a Dart file at OUTPUT_FILE.
# It handles filenames with spaces, hyphens, and capital letters.
# Version: 2.1.0

# --- Configuration ---
ASSETS_DIR="assets"
OUTPUT_FILE="lib/constants/app_assets.dart"
CLASS_NAME="AppAssets"

# --- Script Start ---
# Create the output directory if it doesn't exist
mkdir -p "$(dirname "$OUTPUT_FILE")"

# Clear the existing file and write the header
{
  echo "// This file is generated by a script. Do not edit."
  echo "// For more details, see generate_assets.sh in your project root."
  echo "// Generated at: $(date)"
  echo ""
  echo "class $CLASS_NAME {"
  echo "  const $CLASS_NAME._();"
  echo ""
} > "$OUTPUT_FILE"

# Find top-level directories in the assets folder
find "$ASSETS_DIR" -maxdepth 1 -mindepth 1 -type d | sort | while IFS= read -r dir; do
    folder_name=$(basename "$dir")

    # Rule: Exclude 'fonts' directory
    if [[ "$folder_name" == "fonts" ]]; then
        continue
    fi

    # Rule: Add section comments like // === Images ===
    section_name_capitalized="$(tr '[:lower:]' '[:upper:]' <<< ${folder_name:0:1})${folder_name:1}"
    echo "  // === $section_name_capitalized ===" >> "$OUTPUT_FILE"

    # Rule: Order assets by extension
    extensions=("svg" "png" "jpg" "jpeg" "gif" "webp" "json" "riv" "lottie")

    first_entry_in_section=true
    for ext in "${extensions[@]}"; do
        # Find all files with the current extension, but don't process yet
        files_found=$(find "$dir" -type f -name "*.$ext")
        if [[ -z "$files_found" ]]; then
            continue
        fi

        # Add a comment for the file type, e.g., // .svg
        if [ "$first_entry_in_section" = false ]; then
          echo "" >> "$OUTPUT_FILE"
        fi
        echo "  // .$ext" >> "$OUTPUT_FILE"
        first_entry_in_section=false

        # Use a while read loop to correctly handle filenames with spaces and special chars
        echo "$files_found" | sort | while IFS= read -r file; do
            # --- Generate a clean, camelCase variable name from the file path ---
            
            # 1. Get path relative to assets dir, without extension
            # e.g., 'svg/icons/Arrow - Right 2'
            var_name_base=$(echo "$file" | sed -e "s#^$ASSETS_DIR/##" -e "s#\.$ext##")

            # 2. Sanitize: lowercase, replace invalid chars with underscores, clean up underscores
            # e.g., 'svg_icons_arrow_right_2'
            var_name_snake=$(echo "$var_name_base" | \
                tr '[:upper:]' '[:lower:]' | \
                sed -e 's/[^a-z0-9]\+/_/g' -e 's/^_//' -e 's/_$//')
            
            # 3. Convert snake_case to lowerCamelCase
            # e.g., 'svgIconsArrowRight2'
            var_name_camel=$(echo "$var_name_snake" | awk -F_ '{printf "%s", $1; for(i=2; i<=NF; i++) printf "%s", toupper(substr($i,1,1)) substr($i,2)}')
            
            # 4. Check for empty or invalid names. If empty, skip with a warning.
            if [[ -z "$var_name_camel" ]]; then
                echo "  // WARNING: Could not generate a valid name for asset: $file" >> "$OUTPUT_FILE"
                continue
            fi
            
            # 5. If the name starts with a number, prefix it to make it a valid variable name
            if [[ $var_name_camel =~ ^[0-9] ]]; then
                var_name_camel="asset$var_name_camel"
            fi

            # Write the static constant to the file
            echo "  static const String $var_name_camel = '$file';" >> "$OUTPUT_FILE"
        done
    done
    echo "" >> "$OUTPUT_FILE"
done

# Write the closing brace for the class
echo "}" >> "$OUTPUT_FILE"
